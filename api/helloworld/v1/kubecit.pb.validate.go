// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/helloworld/v1/kubecit.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on HelloRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HelloRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HelloRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HelloRequestMultiError, or
// nil if none found.
func (m *HelloRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HelloRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return HelloRequestMultiError(errors)
	}

	return nil
}

// HelloRequestMultiError is an error wrapping multiple validation errors
// returned by HelloRequest.ValidateAll() if the designated constraints aren't met.
type HelloRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HelloRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HelloRequestMultiError) AllErrors() []error { return m }

// HelloRequestValidationError is the validation error returned by
// HelloRequest.Validate if the designated constraints aren't met.
type HelloRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HelloRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HelloRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HelloRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HelloRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HelloRequestValidationError) ErrorName() string { return "HelloRequestValidationError" }

// Error satisfies the builtin error interface
func (e HelloRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHelloRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HelloRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HelloRequestValidationError{}

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Empty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmptyMultiError, or nil if none found.
func (m *Empty) ValidateAll() error {
	return m.validate(true)
}

func (m *Empty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyMultiError(errors)
	}

	return nil
}

// EmptyMultiError is an error wrapping multiple validation errors returned by
// Empty.ValidateAll() if the designated constraints aren't met.
type EmptyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyMultiError) AllErrors() []error { return m }

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on CategoryResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CategoryResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryRespMultiError, or
// nil if none found.
func (m *CategoryResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCategories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CategoryRespValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CategoryRespValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CategoryRespValidationError{
					field:  fmt.Sprintf("Categories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CategoryRespMultiError(errors)
	}

	return nil
}

// CategoryRespMultiError is an error wrapping multiple validation errors
// returned by CategoryResp.ValidateAll() if the designated constraints aren't met.
type CategoryRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryRespMultiError) AllErrors() []error { return m }

// CategoryRespValidationError is the validation error returned by
// CategoryResp.Validate if the designated constraints aren't met.
type CategoryRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryRespValidationError) ErrorName() string { return "CategoryRespValidationError" }

// Error satisfies the builtin error interface
func (e CategoryRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryRespValidationError{}

// Validate checks the field values on CategoryInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CategoryInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryInfoMultiError, or
// nil if none found.
func (m *CategoryInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CategoryName

	// no validation rules for ParentId

	// no validation rules for Level

	// no validation rules for Status

	// no validation rules for Id

	if len(errors) > 0 {
		return CategoryInfoMultiError(errors)
	}

	return nil
}

// CategoryInfoMultiError is an error wrapping multiple validation errors
// returned by CategoryInfo.ValidateAll() if the designated constraints aren't met.
type CategoryInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryInfoMultiError) AllErrors() []error { return m }

// CategoryInfoValidationError is the validation error returned by
// CategoryInfo.Validate if the designated constraints aren't met.
type CategoryInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryInfoValidationError) ErrorName() string { return "CategoryInfoValidationError" }

// Error satisfies the builtin error interface
func (e CategoryInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryInfoValidationError{}

// Validate checks the field values on HelloReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HelloReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HelloReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HelloReplyMultiError, or
// nil if none found.
func (m *HelloReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HelloReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return HelloReplyMultiError(errors)
	}

	return nil
}

// HelloReplyMultiError is an error wrapping multiple validation errors
// returned by HelloReply.ValidateAll() if the designated constraints aren't met.
type HelloReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HelloReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HelloReplyMultiError) AllErrors() []error { return m }

// HelloReplyValidationError is the validation error returned by
// HelloReply.Validate if the designated constraints aren't met.
type HelloReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HelloReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HelloReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HelloReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HelloReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HelloReplyValidationError) ErrorName() string { return "HelloReplyValidationError" }

// Error satisfies the builtin error interface
func (e HelloReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHelloReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HelloReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HelloReplyValidationError{}

// Validate checks the field values on PageRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageRequestMultiError, or
// nil if none found.
func (m *PageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	if len(errors) > 0 {
		return PageRequestMultiError(errors)
	}

	return nil
}

// PageRequestMultiError is an error wrapping multiple validation errors
// returned by PageRequest.ValidateAll() if the designated constraints aren't met.
type PageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageRequestMultiError) AllErrors() []error { return m }

// PageRequestValidationError is the validation error returned by
// PageRequest.Validate if the designated constraints aren't met.
type PageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageRequestValidationError) ErrorName() string { return "PageRequestValidationError" }

// Error satisfies the builtin error interface
func (e PageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageRequestValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	// no validation rules for Code

	// no validation rules for Success

	// no validation rules for Version

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on MostNewReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MostNewReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MostNewReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MostNewReplyMultiError, or
// nil if none found.
func (m *MostNewReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MostNewReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MostNewReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MostNewReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MostNewReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MostNewReplyMultiError(errors)
	}

	return nil
}

// MostNewReplyMultiError is an error wrapping multiple validation errors
// returned by MostNewReply.ValidateAll() if the designated constraints aren't met.
type MostNewReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MostNewReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MostNewReplyMultiError) AllErrors() []error { return m }

// MostNewReplyValidationError is the validation error returned by
// MostNewReply.Validate if the designated constraints aren't met.
type MostNewReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MostNewReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MostNewReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MostNewReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MostNewReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MostNewReplyValidationError) ErrorName() string { return "MostNewReplyValidationError" }

// Error satisfies the builtin error interface
func (e MostNewReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMostNewReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MostNewReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MostNewReplyValidationError{}

// Validate checks the field values on MostNewReplyData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MostNewReplyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MostNewReplyData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MostNewReplyDataMultiError, or nil if none found.
func (m *MostNewReplyData) ValidateAll() error {
	return m.validate(true)
}

func (m *MostNewReplyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MostNewReplyDataValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MostNewReplyDataValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MostNewReplyDataValidationError{
				field:  "PageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MostNewReplyDataMultiError(errors)
	}

	return nil
}

// MostNewReplyDataMultiError is an error wrapping multiple validation errors
// returned by MostNewReplyData.ValidateAll() if the designated constraints
// aren't met.
type MostNewReplyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MostNewReplyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MostNewReplyDataMultiError) AllErrors() []error { return m }

// MostNewReplyDataValidationError is the validation error returned by
// MostNewReplyData.Validate if the designated constraints aren't met.
type MostNewReplyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MostNewReplyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MostNewReplyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MostNewReplyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MostNewReplyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MostNewReplyDataValidationError) ErrorName() string { return "MostNewReplyDataValidationError" }

// Error satisfies the builtin error interface
func (e MostNewReplyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMostNewReplyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MostNewReplyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MostNewReplyDataValidationError{}

// Validate checks the field values on PageInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageInfoMultiError, or nil
// if none found.
func (m *PageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StartRow

	// no validation rules for LastPage

	// no validation rules for PrePage

	// no validation rules for HasNextPage

	// no validation rules for NextPage

	// no validation rules for PageSize

	// no validation rules for EndRow

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PageInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PageInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PageInfoValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PageNum

	// no validation rules for NavigatePages

	// no validation rules for Total

	// no validation rules for NavigateFirstPage

	// no validation rules for Pages

	// no validation rules for Size

	// no validation rules for FirstPage

	// no validation rules for IsLastPage

	// no validation rules for HasPreviousPage

	// no validation rules for NavigateLastPage

	// no validation rules for IsFirstPage

	if len(errors) > 0 {
		return PageInfoMultiError(errors)
	}

	return nil
}

// PageInfoMultiError is an error wrapping multiple validation errors returned
// by PageInfo.ValidateAll() if the designated constraints aren't met.
type PageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageInfoMultiError) AllErrors() []error { return m }

// PageInfoValidationError is the validation error returned by
// PageInfo.Validate if the designated constraints aren't met.
type PageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageInfoValidationError) ErrorName() string { return "PageInfoValidationError" }

// Error satisfies the builtin error interface
func (e PageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageInfoValidationError{}

// Validate checks the field values on CourseInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CourseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CourseInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CourseInfoMultiError, or
// nil if none found.
func (m *CourseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CourseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsRecommend

	// no validation rules for IsIntegral

	// no validation rules for SecondCategory

	// no validation rules for SaleType

	// no validation rules for DiscountPrice

	// no validation rules for FirstCategory

	// no validation rules for IsMember

	// no validation rules for FirstCategoryName

	// no validation rules for TeachingType

	// no validation rules for CourseLevel

	// no validation rules for UpdateBy

	// no validation rules for PurchaseCnt

	// no validation rules for TotalHour

	// no validation rules for Id

	// no validation rules for CourseCover

	// no validation rules for SalePrice

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CourseInfoValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CourseInfoValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CourseInfoValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tags

	// no validation rules for CourseName

	// no validation rules for CreateBy

	// no validation rules for PurchaseCounter

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CourseInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CourseInfoValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CourseInfoValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Clicks

	// no validation rules for SecondCategoryName

	// no validation rules for Status

	if len(errors) > 0 {
		return CourseInfoMultiError(errors)
	}

	return nil
}

// CourseInfoMultiError is an error wrapping multiple validation errors
// returned by CourseInfo.ValidateAll() if the designated constraints aren't met.
type CourseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CourseInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CourseInfoMultiError) AllErrors() []error { return m }

// CourseInfoValidationError is the validation error returned by
// CourseInfo.Validate if the designated constraints aren't met.
type CourseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CourseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CourseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CourseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CourseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CourseInfoValidationError) ErrorName() string { return "CourseInfoValidationError" }

// Error satisfies the builtin error interface
func (e CourseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCourseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CourseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CourseInfoValidationError{}

// Validate checks the field values on GetFirstCategoriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFirstCategoriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFirstCategoriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFirstCategoriesRequestMultiError, or nil if none found.
func (m *GetFirstCategoriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFirstCategoriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetFirstCategoriesRequestMultiError(errors)
	}

	return nil
}

// GetFirstCategoriesRequestMultiError is an error wrapping multiple validation
// errors returned by GetFirstCategoriesRequest.ValidateAll() if the
// designated constraints aren't met.
type GetFirstCategoriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFirstCategoriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFirstCategoriesRequestMultiError) AllErrors() []error { return m }

// GetFirstCategoriesRequestValidationError is the validation error returned by
// GetFirstCategoriesRequest.Validate if the designated constraints aren't met.
type GetFirstCategoriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFirstCategoriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFirstCategoriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFirstCategoriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFirstCategoriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFirstCategoriesRequestValidationError) ErrorName() string {
	return "GetFirstCategoriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFirstCategoriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFirstCategoriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFirstCategoriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFirstCategoriesRequestValidationError{}

// Validate checks the field values on GetFirstCategoriesReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFirstCategoriesReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFirstCategoriesReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFirstCategoriesReplyMultiError, or nil if none found.
func (m *GetFirstCategoriesReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFirstCategoriesReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCategories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFirstCategoriesReplyValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFirstCategoriesReplyValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFirstCategoriesReplyValidationError{
					field:  fmt.Sprintf("Categories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFirstCategoriesReplyMultiError(errors)
	}

	return nil
}

// GetFirstCategoriesReplyMultiError is an error wrapping multiple validation
// errors returned by GetFirstCategoriesReply.ValidateAll() if the designated
// constraints aren't met.
type GetFirstCategoriesReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFirstCategoriesReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFirstCategoriesReplyMultiError) AllErrors() []error { return m }

// GetFirstCategoriesReplyValidationError is the validation error returned by
// GetFirstCategoriesReply.Validate if the designated constraints aren't met.
type GetFirstCategoriesReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFirstCategoriesReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFirstCategoriesReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFirstCategoriesReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFirstCategoriesReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFirstCategoriesReplyValidationError) ErrorName() string {
	return "GetFirstCategoriesReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetFirstCategoriesReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFirstCategoriesReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFirstCategoriesReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFirstCategoriesReplyValidationError{}

// Validate checks the field values on GetFirstCategoriesReplyData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFirstCategoriesReplyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFirstCategoriesReplyData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFirstCategoriesReplyDataMultiError, or nil if none found.
func (m *GetFirstCategoriesReplyData) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFirstCategoriesReplyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFirstCategoriesReplyDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFirstCategoriesReplyDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFirstCategoriesReplyDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFirstCategoriesReplyDataMultiError(errors)
	}

	return nil
}

// GetFirstCategoriesReplyDataMultiError is an error wrapping multiple
// validation errors returned by GetFirstCategoriesReplyData.ValidateAll() if
// the designated constraints aren't met.
type GetFirstCategoriesReplyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFirstCategoriesReplyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFirstCategoriesReplyDataMultiError) AllErrors() []error { return m }

// GetFirstCategoriesReplyDataValidationError is the validation error returned
// by GetFirstCategoriesReplyData.Validate if the designated constraints
// aren't met.
type GetFirstCategoriesReplyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFirstCategoriesReplyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFirstCategoriesReplyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFirstCategoriesReplyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFirstCategoriesReplyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFirstCategoriesReplyDataValidationError) ErrorName() string {
	return "GetFirstCategoriesReplyDataValidationError"
}

// Error satisfies the builtin error interface
func (e GetFirstCategoriesReplyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFirstCategoriesReplyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFirstCategoriesReplyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFirstCategoriesReplyDataValidationError{}

// Validate checks the field values on FirstCategory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirstCategory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirstCategory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirstCategoryMultiError, or
// nil if none found.
func (m *FirstCategory) ValidateAll() error {
	return m.validate(true)
}

func (m *FirstCategory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Thumbnail

	// no validation rules for Level

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FirstCategoryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FirstCategoryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FirstCategoryValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sort

	// no validation rules for CategoryName

	// no validation rules for ParentId

	// no validation rules for CreateBy

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FirstCategoryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FirstCategoryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FirstCategoryValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdateBy

	// no validation rules for Id

	// no validation rules for Status

	if len(errors) > 0 {
		return FirstCategoryMultiError(errors)
	}

	return nil
}

// FirstCategoryMultiError is an error wrapping multiple validation errors
// returned by FirstCategory.ValidateAll() if the designated constraints
// aren't met.
type FirstCategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirstCategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirstCategoryMultiError) AllErrors() []error { return m }

// FirstCategoryValidationError is the validation error returned by
// FirstCategory.Validate if the designated constraints aren't met.
type FirstCategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirstCategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirstCategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirstCategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirstCategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirstCategoryValidationError) ErrorName() string { return "FirstCategoryValidationError" }

// Error satisfies the builtin error interface
func (e FirstCategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirstCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirstCategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirstCategoryValidationError{}

// Validate checks the field values on TagsListRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TagsListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagsListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TagsListRequestMultiError, or nil if none found.
func (m *TagsListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TagsListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Course

	if len(errors) > 0 {
		return TagsListRequestMultiError(errors)
	}

	return nil
}

// TagsListRequestMultiError is an error wrapping multiple validation errors
// returned by TagsListRequest.ValidateAll() if the designated constraints
// aren't met.
type TagsListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagsListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagsListRequestMultiError) AllErrors() []error { return m }

// TagsListRequestValidationError is the validation error returned by
// TagsListRequest.Validate if the designated constraints aren't met.
type TagsListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagsListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagsListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagsListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagsListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagsListRequestValidationError) ErrorName() string { return "TagsListRequestValidationError" }

// Error satisfies the builtin error interface
func (e TagsListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagsListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagsListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagsListRequestValidationError{}

// Validate checks the field values on TagsListReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TagsListReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagsListReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TagsListReplyMultiError, or
// nil if none found.
func (m *TagsListReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TagsListReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TagsListReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TagsListReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TagsListReplyValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TagsListReplyMultiError(errors)
	}

	return nil
}

// TagsListReplyMultiError is an error wrapping multiple validation errors
// returned by TagsListReply.ValidateAll() if the designated constraints
// aren't met.
type TagsListReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagsListReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagsListReplyMultiError) AllErrors() []error { return m }

// TagsListReplyValidationError is the validation error returned by
// TagsListReply.Validate if the designated constraints aren't met.
type TagsListReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagsListReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagsListReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagsListReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagsListReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagsListReplyValidationError) ErrorName() string { return "TagsListReplyValidationError" }

// Error satisfies the builtin error interface
func (e TagsListReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagsListReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagsListReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagsListReplyValidationError{}

// Validate checks the field values on Tag with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagMultiError, or nil if none found.
func (m *Tag) ValidateAll() error {
	return m.validate(true)
}

func (m *Tag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return TagMultiError(errors)
	}

	return nil
}

// TagMultiError is an error wrapping multiple validation errors returned by
// Tag.ValidateAll() if the designated constraints aren't met.
type TagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagMultiError) AllErrors() []error { return m }

// TagValidationError is the validation error returned by Tag.Validate if the
// designated constraints aren't met.
type TagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagValidationError) ErrorName() string { return "TagValidationError" }

// Error satisfies the builtin error interface
func (e TagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagValidationError{}

// Validate checks the field values on SearchCourseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchCourseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchCourseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchCourseRequestMultiError, or nil if none found.
func (m *SearchCourseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchCourseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Category

	if len(errors) > 0 {
		return SearchCourseRequestMultiError(errors)
	}

	return nil
}

// SearchCourseRequestMultiError is an error wrapping multiple validation
// errors returned by SearchCourseRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchCourseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchCourseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchCourseRequestMultiError) AllErrors() []error { return m }

// SearchCourseRequestValidationError is the validation error returned by
// SearchCourseRequest.Validate if the designated constraints aren't met.
type SearchCourseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchCourseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchCourseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchCourseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchCourseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchCourseRequestValidationError) ErrorName() string {
	return "SearchCourseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchCourseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchCourseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchCourseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchCourseRequestValidationError{}

// Validate checks the field values on SearchCourseReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SearchCourseReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchCourseReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchCourseReplyMultiError, or nil if none found.
func (m *SearchCourseReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchCourseReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchCourseReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchCourseReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchCourseReplyValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchCourseReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchCourseReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchCourseReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SearchCourseReplyMultiError(errors)
	}

	return nil
}

// SearchCourseReplyMultiError is an error wrapping multiple validation errors
// returned by SearchCourseReply.ValidateAll() if the designated constraints
// aren't met.
type SearchCourseReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchCourseReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchCourseReplyMultiError) AllErrors() []error { return m }

// SearchCourseReplyValidationError is the validation error returned by
// SearchCourseReply.Validate if the designated constraints aren't met.
type SearchCourseReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchCourseReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchCourseReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchCourseReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchCourseReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchCourseReplyValidationError) ErrorName() string {
	return "SearchCourseReplyValidationError"
}

// Error satisfies the builtin error interface
func (e SearchCourseReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchCourseReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchCourseReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchCourseReplyValidationError{}

// Validate checks the field values on SliderInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SliderInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SliderInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SliderInfoMultiError, or
// nil if none found.
func (m *SliderInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SliderInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for ImageLink

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliderInfoValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliderInfoValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliderInfoValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SliderInfoValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SliderInfoValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SliderInfoValidationError{
				field:  "UpdateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsValid

	// no validation rules for Priority

	if len(errors) > 0 {
		return SliderInfoMultiError(errors)
	}

	return nil
}

// SliderInfoMultiError is an error wrapping multiple validation errors
// returned by SliderInfo.ValidateAll() if the designated constraints aren't met.
type SliderInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SliderInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SliderInfoMultiError) AllErrors() []error { return m }

// SliderInfoValidationError is the validation error returned by
// SliderInfo.Validate if the designated constraints aren't met.
type SliderInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SliderInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SliderInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SliderInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SliderInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SliderInfoValidationError) ErrorName() string { return "SliderInfoValidationError" }

// Error satisfies the builtin error interface
func (e SliderInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSliderInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SliderInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SliderInfoValidationError{}

// Validate checks the field values on CreateSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSliderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSliderRequestMultiError, or nil if none found.
func (m *CreateSliderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSliderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for ImageLink

	// no validation rules for IsValid

	// no validation rules for Priority

	if len(errors) > 0 {
		return CreateSliderRequestMultiError(errors)
	}

	return nil
}

// CreateSliderRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSliderRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSliderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSliderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSliderRequestMultiError) AllErrors() []error { return m }

// CreateSliderRequestValidationError is the validation error returned by
// CreateSliderRequest.Validate if the designated constraints aren't met.
type CreateSliderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSliderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSliderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSliderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSliderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSliderRequestValidationError) ErrorName() string {
	return "CreateSliderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSliderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSliderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSliderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSliderRequestValidationError{}

// Validate checks the field values on CreateSliderReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateSliderReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSliderReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSliderReplyMultiError, or nil if none found.
func (m *CreateSliderReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSliderReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSliderReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSliderReplyMultiError(errors)
	}

	return nil
}

// CreateSliderReplyMultiError is an error wrapping multiple validation errors
// returned by CreateSliderReply.ValidateAll() if the designated constraints
// aren't met.
type CreateSliderReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSliderReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSliderReplyMultiError) AllErrors() []error { return m }

// CreateSliderReplyValidationError is the validation error returned by
// CreateSliderReply.Validate if the designated constraints aren't met.
type CreateSliderReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSliderReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSliderReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSliderReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSliderReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSliderReplyValidationError) ErrorName() string {
	return "CreateSliderReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSliderReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSliderReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSliderReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSliderReplyValidationError{}

// Validate checks the field values on GetSliderRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSliderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSliderRequestMultiError, or nil if none found.
func (m *GetSliderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSliderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetSliderRequestMultiError(errors)
	}

	return nil
}

// GetSliderRequestMultiError is an error wrapping multiple validation errors
// returned by GetSliderRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSliderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSliderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSliderRequestMultiError) AllErrors() []error { return m }

// GetSliderRequestValidationError is the validation error returned by
// GetSliderRequest.Validate if the designated constraints aren't met.
type GetSliderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSliderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSliderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSliderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSliderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSliderRequestValidationError) ErrorName() string { return "GetSliderRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetSliderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSliderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSliderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSliderRequestValidationError{}

// Validate checks the field values on GetSliderReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetSliderReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSliderReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetSliderReplyMultiError,
// or nil if none found.
func (m *GetSliderReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSliderReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSliderReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSliderReplyMultiError(errors)
	}

	return nil
}

// GetSliderReplyMultiError is an error wrapping multiple validation errors
// returned by GetSliderReply.ValidateAll() if the designated constraints
// aren't met.
type GetSliderReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSliderReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSliderReplyMultiError) AllErrors() []error { return m }

// GetSliderReplyValidationError is the validation error returned by
// GetSliderReply.Validate if the designated constraints aren't met.
type GetSliderReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSliderReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSliderReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSliderReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSliderReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSliderReplyValidationError) ErrorName() string { return "GetSliderReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetSliderReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSliderReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSliderReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSliderReplyValidationError{}

// Validate checks the field values on DeleteSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSliderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSliderRequestMultiError, or nil if none found.
func (m *DeleteSliderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSliderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteSliderRequestMultiError(errors)
	}

	return nil
}

// DeleteSliderRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSliderRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSliderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSliderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSliderRequestMultiError) AllErrors() []error { return m }

// DeleteSliderRequestValidationError is the validation error returned by
// DeleteSliderRequest.Validate if the designated constraints aren't met.
type DeleteSliderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSliderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSliderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSliderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSliderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSliderRequestValidationError) ErrorName() string {
	return "DeleteSliderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSliderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSliderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSliderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSliderRequestValidationError{}

// Validate checks the field values on DeleteSliderReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteSliderReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSliderReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSliderReplyMultiError, or nil if none found.
func (m *DeleteSliderReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSliderReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if len(errors) > 0 {
		return DeleteSliderReplyMultiError(errors)
	}

	return nil
}

// DeleteSliderReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteSliderReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteSliderReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSliderReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSliderReplyMultiError) AllErrors() []error { return m }

// DeleteSliderReplyValidationError is the validation error returned by
// DeleteSliderReply.Validate if the designated constraints aren't met.
type DeleteSliderReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSliderReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSliderReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSliderReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSliderReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSliderReplyValidationError) ErrorName() string {
	return "DeleteSliderReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSliderReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSliderReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSliderReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSliderReplyValidationError{}

// Validate checks the field values on UpdateSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSliderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSliderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSliderRequestMultiError, or nil if none found.
func (m *UpdateSliderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSliderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for ImageLink

	// no validation rules for IsValid

	// no validation rules for Priority

	if len(errors) > 0 {
		return UpdateSliderRequestMultiError(errors)
	}

	return nil
}

// UpdateSliderRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSliderRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSliderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSliderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSliderRequestMultiError) AllErrors() []error { return m }

// UpdateSliderRequestValidationError is the validation error returned by
// UpdateSliderRequest.Validate if the designated constraints aren't met.
type UpdateSliderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSliderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSliderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSliderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSliderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSliderRequestValidationError) ErrorName() string {
	return "UpdateSliderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSliderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSliderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSliderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSliderRequestValidationError{}

// Validate checks the field values on UpdateSliderReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateSliderReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSliderReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSliderReplyMultiError, or nil if none found.
func (m *UpdateSliderReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSliderReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSliderReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSliderReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSliderReplyMultiError(errors)
	}

	return nil
}

// UpdateSliderReplyMultiError is an error wrapping multiple validation errors
// returned by UpdateSliderReply.ValidateAll() if the designated constraints
// aren't met.
type UpdateSliderReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSliderReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSliderReplyMultiError) AllErrors() []error { return m }

// UpdateSliderReplyValidationError is the validation error returned by
// UpdateSliderReply.Validate if the designated constraints aren't met.
type UpdateSliderReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSliderReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSliderReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSliderReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSliderReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSliderReplyValidationError) ErrorName() string {
	return "UpdateSliderReplyValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSliderReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSliderReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSliderReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSliderReplyValidationError{}

// Validate checks the field values on ListSlidersByPriorityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSlidersByPriorityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSlidersByPriorityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSlidersByPriorityRequestMultiError, or nil if none found.
func (m *ListSlidersByPriorityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSlidersByPriorityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Priority

	// no validation rules for Count

	if len(errors) > 0 {
		return ListSlidersByPriorityRequestMultiError(errors)
	}

	return nil
}

// ListSlidersByPriorityRequestMultiError is an error wrapping multiple
// validation errors returned by ListSlidersByPriorityRequest.ValidateAll() if
// the designated constraints aren't met.
type ListSlidersByPriorityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSlidersByPriorityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSlidersByPriorityRequestMultiError) AllErrors() []error { return m }

// ListSlidersByPriorityRequestValidationError is the validation error returned
// by ListSlidersByPriorityRequest.Validate if the designated constraints
// aren't met.
type ListSlidersByPriorityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSlidersByPriorityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSlidersByPriorityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSlidersByPriorityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSlidersByPriorityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSlidersByPriorityRequestValidationError) ErrorName() string {
	return "ListSlidersByPriorityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSlidersByPriorityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSlidersByPriorityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSlidersByPriorityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSlidersByPriorityRequestValidationError{}

// Validate checks the field values on ListSlidersByPriorityReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSlidersByPriorityReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSlidersByPriorityReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSlidersByPriorityReplyMultiError, or nil if none found.
func (m *ListSlidersByPriorityReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSlidersByPriorityReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSlidersByPriorityReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSlidersByPriorityReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSlidersByPriorityReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSlidersByPriorityReplyMultiError(errors)
	}

	return nil
}

// ListSlidersByPriorityReplyMultiError is an error wrapping multiple
// validation errors returned by ListSlidersByPriorityReply.ValidateAll() if
// the designated constraints aren't met.
type ListSlidersByPriorityReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSlidersByPriorityReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSlidersByPriorityReplyMultiError) AllErrors() []error { return m }

// ListSlidersByPriorityReplyValidationError is the validation error returned
// by ListSlidersByPriorityReply.Validate if the designated constraints aren't met.
type ListSlidersByPriorityReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSlidersByPriorityReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSlidersByPriorityReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSlidersByPriorityReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSlidersByPriorityReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSlidersByPriorityReplyValidationError) ErrorName() string {
	return "ListSlidersByPriorityReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListSlidersByPriorityReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSlidersByPriorityReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSlidersByPriorityReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSlidersByPriorityReplyValidationError{}

// Validate checks the field values on CreateTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTokenRequestMultiError, or nil if none found.
func (m *CreateTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateTokenRequestMultiError(errors)
	}

	return nil
}

// CreateTokenRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTokenRequestMultiError) AllErrors() []error { return m }

// CreateTokenRequestValidationError is the validation error returned by
// CreateTokenRequest.Validate if the designated constraints aren't met.
type CreateTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTokenRequestValidationError) ErrorName() string {
	return "CreateTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTokenRequestValidationError{}

// Validate checks the field values on CreateTokenReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTokenReplyMultiError, or nil if none found.
func (m *CreateTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTokenReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTokenReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTokenReplyValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Data

	if len(errors) > 0 {
		return CreateTokenReplyMultiError(errors)
	}

	return nil
}

// CreateTokenReplyMultiError is an error wrapping multiple validation errors
// returned by CreateTokenReply.ValidateAll() if the designated constraints
// aren't met.
type CreateTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTokenReplyMultiError) AllErrors() []error { return m }

// CreateTokenReplyValidationError is the validation error returned by
// CreateTokenReply.Validate if the designated constraints aren't met.
type CreateTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTokenReplyValidationError) ErrorName() string { return "CreateTokenReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTokenReplyValidationError{}

// Validate checks the field values on GetInfoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInfoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetInfoRequestMultiError,
// or nil if none found.
func (m *GetInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetInfoRequestMultiError(errors)
	}

	return nil
}

// GetInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInfoRequestMultiError) AllErrors() []error { return m }

// GetInfoRequestValidationError is the validation error returned by
// GetInfoRequest.Validate if the designated constraints aren't met.
type GetInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInfoRequestValidationError) ErrorName() string { return "GetInfoRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInfoRequestValidationError{}

// Validate checks the field values on UserInfoReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoReplyMultiError, or
// nil if none found.
func (m *UserInfoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for RoleId

	// no validation rules for Channel

	if len(errors) > 0 {
		return UserInfoReplyMultiError(errors)
	}

	return nil
}

// UserInfoReplyMultiError is an error wrapping multiple validation errors
// returned by UserInfoReply.ValidateAll() if the designated constraints
// aren't met.
type UserInfoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoReplyMultiError) AllErrors() []error { return m }

// UserInfoReplyValidationError is the validation error returned by
// UserInfoReply.Validate if the designated constraints aren't met.
type UserInfoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoReplyValidationError) ErrorName() string { return "UserInfoReplyValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoReplyValidationError{}

// Validate checks the field values on GetInfoReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetInfoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInfoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetInfoReplyMultiError, or
// nil if none found.
func (m *GetInfoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInfoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInfoReplyMultiError(errors)
	}

	return nil
}

// GetInfoReplyMultiError is an error wrapping multiple validation errors
// returned by GetInfoReply.ValidateAll() if the designated constraints aren't met.
type GetInfoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInfoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInfoReplyMultiError) AllErrors() []error { return m }

// GetInfoReplyValidationError is the validation error returned by
// GetInfoReply.Validate if the designated constraints aren't met.
type GetInfoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInfoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInfoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInfoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInfoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInfoReplyValidationError) ErrorName() string { return "GetInfoReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetInfoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInfoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInfoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInfoReplyValidationError{}

// Validate checks the field values on GetInfoReplyData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetInfoReplyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInfoReplyData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInfoReplyDataMultiError, or nil if none found.
func (m *GetInfoReplyData) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInfoReplyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBirthday()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBirthday()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyDataValidationError{
				field:  "Birthday",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SysCode

	// no validation rules for Gender

	// no validation rules for City

	// no validation rules for County

	// no validation rules for HighestEducation

	// no validation rules for IsEnable

	// no validation rules for Password

	// no validation rules for Province

	// no validation rules for UpdateBy

	// no validation rules for TotalHour

	// no validation rules for Id

	// no validation rules for PlatformAuthuser

	// no validation rules for Email

	// no validation rules for Qq

	// no validation rules for Address

	// no validation rules for NickName

	// no validation rules for EmergencyContact

	// no validation rules for EmergencyContactNumber

	// no validation rules for Mobile

	// no validation rules for Wechat

	// no validation rules for RegSource

	// no validation rules for Telephone

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyDataValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Avatar

	// no validation rules for RealName

	// no validation rules for CreateBy

	if all {
		switch v := interface{}(m.GetVipInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "VipInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "VipInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVipInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyDataValidationError{
				field:  "VipInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PersonalSignature

	// no validation rules for CertificateNumber

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInfoReplyDataValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInfoReplyDataValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Age

	// no validation rules for ResidenceAddress

	// no validation rules for Username

	// no validation rules for CertificateType

	if len(errors) > 0 {
		return GetInfoReplyDataMultiError(errors)
	}

	return nil
}

// GetInfoReplyDataMultiError is an error wrapping multiple validation errors
// returned by GetInfoReplyData.ValidateAll() if the designated constraints
// aren't met.
type GetInfoReplyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInfoReplyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInfoReplyDataMultiError) AllErrors() []error { return m }

// GetInfoReplyDataValidationError is the validation error returned by
// GetInfoReplyData.Validate if the designated constraints aren't met.
type GetInfoReplyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInfoReplyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInfoReplyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInfoReplyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInfoReplyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInfoReplyDataValidationError) ErrorName() string { return "GetInfoReplyDataValidationError" }

// Error satisfies the builtin error interface
func (e GetInfoReplyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInfoReplyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInfoReplyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInfoReplyDataValidationError{}

// Validate checks the field values on MemberVIPInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MemberVIPInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MemberVIPInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MemberVIPInfoMultiError, or
// nil if none found.
func (m *MemberVIPInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MemberVIPInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderNumber

	// no validation rules for VipName

	// no validation rules for VipId

	// no validation rules for VipDesc

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberVIPInfoValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberVIPInfoValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberVIPInfoValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MemberVIPInfoValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MemberVIPInfoValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MemberVIPInfoValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsExpired

	// no validation rules for MemberId

	// no validation rules for VipIcon

	if len(errors) > 0 {
		return MemberVIPInfoMultiError(errors)
	}

	return nil
}

// MemberVIPInfoMultiError is an error wrapping multiple validation errors
// returned by MemberVIPInfo.ValidateAll() if the designated constraints
// aren't met.
type MemberVIPInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MemberVIPInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MemberVIPInfoMultiError) AllErrors() []error { return m }

// MemberVIPInfoValidationError is the validation error returned by
// MemberVIPInfo.Validate if the designated constraints aren't met.
type MemberVIPInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MemberVIPInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MemberVIPInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MemberVIPInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MemberVIPInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MemberVIPInfoValidationError) ErrorName() string { return "MemberVIPInfoValidationError" }

// Error satisfies the builtin error interface
func (e MemberVIPInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMemberVIPInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MemberVIPInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MemberVIPInfoValidationError{}

// Validate checks the field values on LoginByJsonRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginByJsonRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginByJsonRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginByJsonRequestMultiError, or nil if none found.
func (m *LoginByJsonRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginByJsonRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginByJsonRequestMultiError(errors)
	}

	return nil
}

// LoginByJsonRequestMultiError is an error wrapping multiple validation errors
// returned by LoginByJsonRequest.ValidateAll() if the designated constraints
// aren't met.
type LoginByJsonRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginByJsonRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginByJsonRequestMultiError) AllErrors() []error { return m }

// LoginByJsonRequestValidationError is the validation error returned by
// LoginByJsonRequest.Validate if the designated constraints aren't met.
type LoginByJsonRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginByJsonRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginByJsonRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginByJsonRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginByJsonRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginByJsonRequestValidationError) ErrorName() string {
	return "LoginByJsonRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoginByJsonRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginByJsonRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginByJsonRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginByJsonRequestValidationError{}

// Validate checks the field values on LoginByJsonReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginByJsonReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginByJsonReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginByJsonReplyMultiError, or nil if none found.
func (m *LoginByJsonReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginByJsonReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginByJsonReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginByJsonReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginByJsonReplyValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginByJsonReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginByJsonReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginByJsonReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginByJsonReplyMultiError(errors)
	}

	return nil
}

// LoginByJsonReplyMultiError is an error wrapping multiple validation errors
// returned by LoginByJsonReply.ValidateAll() if the designated constraints
// aren't met.
type LoginByJsonReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginByJsonReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginByJsonReplyMultiError) AllErrors() []error { return m }

// LoginByJsonReplyValidationError is the validation error returned by
// LoginByJsonReply.Validate if the designated constraints aren't met.
type LoginByJsonReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginByJsonReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginByJsonReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginByJsonReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginByJsonReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginByJsonReplyValidationError) ErrorName() string { return "LoginByJsonReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginByJsonReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginByJsonReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginByJsonReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginByJsonReplyValidationError{}

// Validate checks the field values on RegisterUsernameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterUsernameRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterUsernameRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterUsernameRequestMultiError, or nil if none found.
func (m *RegisterUsernameRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterUsernameRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RegisterUsernameRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := RegisterUsernameRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 6 {
		err := RegisterUsernameRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterUsernameRequestMultiError(errors)
	}

	return nil
}

// RegisterUsernameRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterUsernameRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterUsernameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterUsernameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterUsernameRequestMultiError) AllErrors() []error { return m }

// RegisterUsernameRequestValidationError is the validation error returned by
// RegisterUsernameRequest.Validate if the designated constraints aren't met.
type RegisterUsernameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterUsernameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterUsernameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterUsernameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterUsernameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterUsernameRequestValidationError) ErrorName() string {
	return "RegisterUsernameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterUsernameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterUsernameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterUsernameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterUsernameRequestValidationError{}

var _RegisterUsernameRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z0-9]+$")

// Validate checks the field values on RegisterUsernameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterUsernameReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterUsernameReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterUsernameReplyMultiError, or nil if none found.
func (m *RegisterUsernameReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterUsernameReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterUsernameReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterUsernameReplyValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterUsernameReplyValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterUsernameReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterUsernameReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterUsernameReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterUsernameReplyMultiError(errors)
	}

	return nil
}

// RegisterUsernameReplyMultiError is an error wrapping multiple validation
// errors returned by RegisterUsernameReply.ValidateAll() if the designated
// constraints aren't met.
type RegisterUsernameReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterUsernameReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterUsernameReplyMultiError) AllErrors() []error { return m }

// RegisterUsernameReplyValidationError is the validation error returned by
// RegisterUsernameReply.Validate if the designated constraints aren't met.
type RegisterUsernameReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterUsernameReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterUsernameReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterUsernameReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterUsernameReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterUsernameReplyValidationError) ErrorName() string {
	return "RegisterUsernameReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterUsernameReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterUsernameReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterUsernameReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterUsernameReplyValidationError{}

// Validate checks the field values on LoginByJsonReplyData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginByJsonReplyData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginByJsonReplyData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginByJsonReplyDataMultiError, or nil if none found.
func (m *LoginByJsonReplyData) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginByJsonReplyData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return LoginByJsonReplyDataMultiError(errors)
	}

	return nil
}

// LoginByJsonReplyDataMultiError is an error wrapping multiple validation
// errors returned by LoginByJsonReplyData.ValidateAll() if the designated
// constraints aren't met.
type LoginByJsonReplyDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginByJsonReplyDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginByJsonReplyDataMultiError) AllErrors() []error { return m }

// LoginByJsonReplyDataValidationError is the validation error returned by
// LoginByJsonReplyData.Validate if the designated constraints aren't met.
type LoginByJsonReplyDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginByJsonReplyDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginByJsonReplyDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginByJsonReplyDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginByJsonReplyDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginByJsonReplyDataValidationError) ErrorName() string {
	return "LoginByJsonReplyDataValidationError"
}

// Error satisfies the builtin error interface
func (e LoginByJsonReplyDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginByJsonReplyData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginByJsonReplyDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginByJsonReplyDataValidationError{}
